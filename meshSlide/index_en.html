<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>meshWeather</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>MeshWeather</h2><br/>
					<h6>Arduino Weather station for monitoring field data</h6>
					<img src="img/esempio.png" height="380px"/>
				</section>

				<section>
					<section>
						<h3>Hardware</h3>
						<p class="fragment"> We did a big mistake...<br/>
							... choose (and buy) the hardware before to analyze the problem</p>
					</section>
					<section>
						<ul>
							<li> ESP-01, so many, so much... <br/>
								<img src="img/ESP-01.png"/>
							</li>
							<li>
								Arduino and some sensors
							</li>
						</ul>
					</section>
					<section>
						<h4>The circuit to manage the ESP-01</h4>
						<ul>
							<li class="fragment">
								For the bootloading phase we use <br/> <center><a href="http://fritzing.org/projects/esp01-development-board">ESP01-developer-board</a></center> 
							</li>
							<li class="fragment">
								For the regular usage we build a circuit, <a href="usage-only.fzz">download it</a>, with tensor regulator
							</li>
						</ul>
						<div>	
							<img src="img/devBoard.png" height="170px" />
							<img src="img/usageMode.png" height="170px" alt="usageMode"/>
						</div>
					</section>
				</section>

				<section>
					<section>
						<h3>Software</h3>
						<p>(The funny part)</p>
					</section>
					<section>
						<h4>What we did... </h4>
						<ul>
							<li class="fragment"> 
								1: Flashing the bootloader (<a href="https://h3ron.com/post/programmare-lesp8266-ovvero-arduino-con-il-wifi-a-meno-di-2/">more details here...</a>)
							</li>
							<li class="fragment">
								2: Search and find a library to manage Mesh Network
								<ul>
									<li class="fragment"><a href="https://github.com/esp8266/Arduino/tree/master/libraries/ESP8266WiFi">Arduino ESP8266-WiFi</a></li>
									<li class="fragment">used to build another library: <a href="https://github.com/alessandro308/easyMesh">easyMesh</a></li>
								</ul>
							</li>
							<li class="fragment">
								3: Build our mesh network (code on <a href="https://github.com/alessandro308/MeshWeather">GitHub</a>)
							</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Communication protocols</h2>
						<h4>3 communication mode</h4>
						<ul>
							<li class="fragment">Serial - Arduino, ESP-01
								<p style="font-size: 0.7em">
									Pure serial linking, used to send JSON data that contains the sensors read values.
								</p>
							</li>
							<li class="fragment">Wifi - ESP-01, ESP-01
								<p style="font-size: 0.7em">
									Virtual ad hoc mesh network, build with many point-to-point wifi connections.
								</p>
							</li>
							<li class="fragment">Wifi/Seriale - ESP-01, Server
								<p style="font-size: 0.7em">
									Serial (or Wifi) link, used to receive al network packets and send them to pc that analyze all data.
								</p>
							</li>
						</ul>
					</section>
					<section>
						<h2>Serial-Arduino link</h2>
						<ul>
							<li>Not so realible</li>
							<li>Differente voltage (5V VS 3.3V)</li>
						</ul>
					</section>
					<section>
						<h2>Mesh network protocol</h2>
						Directed Diffusion
						<hr/>
						<div class="fragment " style="font-size: 0.7em">
							<h4>Discovery</h4>
							Inviata dal server ai suoi vicini e propagata in broadcast fra i nodi, viene usata per costuire l'albero di copertura della rete così da evitare il formarsi di cicli.
<pre><code class="JSON fragment grow">{ 
	"from" : uint32_t idServer, 
	"updat_number" : int currentUpdateNumber, 
	"sender_id" : uint32_t prevHopId, 
	"type" :  0 
}</code></pre>
							Alternativamente si potrebbe usare l'<font color="#33cccc">RSS</font>. Si è testato ma per le distanze usate era tutto molto variabile e poco affidabile con il rischio di creare una rete piatta.
						</div>
					</section>
					<section>
						<h2>Protocollo della rete mesh</h2>
						Directed Diffusion
						<hr/>
						<div class="fragment" style="font-size: 0.7em">
							<h4>Fowarding/Data</h4>
							Ogni volta che un nodo riceve un pacchetto lo <font color="#33cccc">inoltro al nodo successivo</font>. Se non esiste lo mando in <font color="#33cccc">broadcast</font>. <br/> <br/>
							Non è stata volontariamente gestita la <font color="#33cccc">pardita di pacchetti</font> poichè i dati raccolti differiscono poco dai precedenti e quindi non è necessario un campionamento eccessivo. Inoltre una nuova richiesta di interesse del sink provvederà, qualora sia necessario, a ricostruire la rotta con una frequenza adeguata alla situazione (parametro della rete).
						</div>
					</section>
					<section>
						<h2>Protocollo della rete mesh</h2>
						Directed Diffusion
						<hr/>
						<div style="font-size: 0.7em">
							<h4>Strutture dati</h4>
							<ul>
								<li><div class="fragment grow"><pre><code class="C">int lastPId[30];
uint32_t lastCId[30];</code></pre></div>Dizionario attraverso il quale si evita la diffusione di pacchetti duplicati all'interno della rete. 
								</li>
								<li>
								<div class="fragment grow"><pre><code class="C">int update, lastSyncTime</code></pre></div>Gestite dal server e usate nella fase di discovery per comunicare ai nodi l’aggiornamento delle rotte e l’avvio di una nuova fase di sincronizzazione.
								</li>
							</ul>
						</div>
					</section>
					<section>
						<h2>Protocollo della rete mesh</h2>
						Directed Diffusion
						<hr/>
						<div class="fragment" style="font-size: 0.7em">
							<h4>Nodo Station / Nodo Server</h4>
							La rete è completamente composta da ESP-01. <br/>A seconda del loro ruolo, tuttavia, possiamo distinguerli in 3 categorie: <br/> </br/>
							<ul>
								<li>
									<font color="#33cccc">Station</font>. Il compito di nodi di questo tipo è quello di leggere i dati dai sensori, creare un pacchetto di tipo DATA e inviarlo al server.
								</li>
								<li>
								 	<font color="#33cccc">GenericNode</font>. I nodi intermedi si occupano esclusivamente di inoltrare i pacchetti dati verso il server e le discoveryReq a tutti vicini.
								</li>
								<li>
								 	<font color="#33cccc">espServer</font>. Il/i server lanciano periodicamente una discoveryReq e si preoccupano di inviare sulla porta seriale tutti i <b>nuovi</b> pacchetti dati.

								</li>
							</ul>
						</div>
					</section>
					<section>
						<h2>Protocollo della rete mesh</h2>
						Directed Diffusion
						<hr/>
						<div style="font-size: 0.7em">
							<h4>Discovery nel server</h4>
							Implementata da discoveryTree(), crea e invia un pacchetto per reinizzializzare l’albero di copertura della rete e risincronizzare i nodi
						<div class="fragment grow" >
							<pre><code class="C">void discoveryTree(){ 
  char msg[256];
  sprintf(msg, "{\"from\": %d, \"update_number\": %d, \"sender_id\": %d,
  \"type\": 0}", mesh.getChipId(), ++update, mesh.getChipId());
  /*Prevent overflow*/
  if(update == INT_MAX)
    update = 0;
  String p(msg);
  mesh.sendBroadcast(p);
  lastSyncTime = mesh.getNodeTime();
  return; 
}
</code></pre></div>
						</div>
					</section>
					<section>
						<h2>Protocollo della rete mesh</h2>
						Directed Diffusion
						<hr/>
						<div style="font-size: 0.7em">
							<h4>Discovery nei nodi</h4>
							Si aggiorna la rotta con la più recente.
						<div class="fragment grow" >
							<pre><code class="C">void receivedCallback( uint32_t from, String &msg_str ){
  JsonObject& msg = jsonBuffer.parseObject(msg_str);
  int type = msg["type"];
  switch(type){  
    case(DISCOVERY_REQ):{
        if(msg["update_number"] > update){
          update = msg["update_number"];
          nextHopId = msg["sender_id"];
          propagateDiscovery(msg);
          lastSyncTime = mesh.getNodeTime();
        }
    }break;
    [...]
  }
}
</code></pre></div>
						</div>
					</section>
					<section>
						<h2>Protocollo della rete mesh</h2>
						Directed Diffusion
						<hr/>
						<div style="font-size: 0.7em">
							<h4>Gestione pacchetto dati nel server</h4>
							Il server ESP-01 spedisce tutti i pacchetti che riceve sul seriale, delegando al computer (decisamente con più capacità di calcolo), di organizzare il tutto e scartare i pacchetti duplicati.
						<div class="fragment grow" >
							<pre><code class="C">void receivedCallback( uint32_t from, String &msg_str ){
  JsonObject& message = jsonBuffer.parseObject(msg_str);
  int type = message["type"];
  if(type!=DISCOVERY_REQ)
    printJson(message);
}

</code></pre></div>
						</div>
					</section>
				</section>
				<section>
					<section>
						<h3>La nostra demo</h3>
						<h6>Cioè un modello semplificato</h6>
					</section>
					<section>
						<p>La stazione Arduino viene simulata direttamente su un ESP-01.</p>
								<pre><code class="c">void loop(){
	[...]
	char msg[100];
	sprintf(msg, "{\"temp\": %f", getTemp());
	mesh.sendBroadcast(msg);
}</code></pre>
						<p style="font-size: 0.6em">Tale semplificazione è giustificabile dal fatto che nel caso in cui si hanno due sensori di raccolta dati, questi possono essere raccolti direttamente con un ESP-01 senza necessità di un microcontrollore esterno.</p>
					</section>
					<section>
						<p>Abbiamo 3 ESP-01, quello connesso al server ignora i pacchetti che gli arrivano dal primo</p>
						<pre><code class="c">void receivedCallback( uint32_t from, String &msg_str ){
  if(from == 2008034 /*ID dell'ESP-01 che genera i dati*/)
    return;
    [...]
    }</code></pre>
					</section>
					<section>
						<p>I dati raccolti non vengono analizzati ma semplicemente salvati su un server (<a href="https://thingspeak.com">ThingSpeak</a>)</p>
						<div class="fragment"><p>Let's start!</p>
						<iframe class="fragment grow" width="450" height="250" style="border: 1px solid #cccccc;" src="http://thingspeak.com/channels/274077/charts/1" id="iframeid"></iframe>
						</div>
						<script>
							window.setInterval(function(){
								var iframe = document.getElementById('iframeid');
								var src = iframe.src;
								iframe.src = "";
								iframe.src = src;
							}, 6000);
							
						</script>
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
